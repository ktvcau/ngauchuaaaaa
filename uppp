const config = {
  name: "kit",
  usage: "kitt <ID>",
  aliases: ["kit", "kicktag"],
  description: "Kick R·ªìi Tag Li√™n T·ª•c",
  credits: "XIE",
};

let isBotStopped = false;

function kick(userID, threadID) {
  return new Promise((resolve, reject) => {
    global.api.removeUserFromGroup(userID, threadID, (err) => {
      if (err) return reject(err);
      resolve();
    });
  });
}

function add(userID, threadID) {
  return new Promise((resolve, reject) => {
    global.api.addUserToGroup(userID, threadID, (err) => {
      if (err) return reject(err);
      resolve();
    });
  });
}

async function getUserName(userID) {
  return new Promise((resolve, reject) => {
    global.api.getUserInfo(userID, (err, info) => {
      if (err) return reject(err);
      const userName = info[userID]?.name || `@${userID}`;
      resolve(userName);
    });
  });
}

function getRandomMessage() {
  const rdmes = [
    "√™ con  ch·∫°y k√¨a ae :))))",
    "con  l√†m ƒë∆∞·ª£c g√¨ kh√¥ngüò§",
    "con  ch·ªâ bi·∫øt ph·∫£n kh√°ngü§≠=))",
    "tk ngu  ph·∫£n kh√°ng diüòè?",
    "con m·∫π m ƒëang c·∫ßu xin t tha cho m k√¨a  üòè",
    "thg ngu  ƒÉn c·ª©t c·ªßa anh m√† =)))",
    "m ƒëang c·∫ßu xin a tha m√† dko  :)))",
    "m b·ªã a h√†nh m√†  c·∫ßu xin a tha ƒëi thg d·ªët =))))",
    "con  b·ªã a ch·ª≠i ƒë·∫øn m·ª©c ph·∫£i c·∫ßu c·ª©u ae m√† =))))",
    "thg t·∫≠t m·ªì c√¥i  lmj c√≥ ba m·∫π n√® =))))",
    "m c√≥ ba m·∫π nh∆∞ t k  :))))",
    "m lmj c√≥ dko  :)))))",
    "m nh√† c√πng b√† ngo·∫°i u70 m√† dko  =))))",
    "con  ƒëc b·∫£ l·∫•y d√∫ 20cm cho b√∫ :)))",
    "tk l·ªìn  ng·∫≠m ƒë·∫Øng nu·ªët cay :))",
    "ng√¥n m ph√®n d·ªØ v  :)))))",
    "tao ch·ª≠i ch∆∞ m·∫Øng m·∫π m n·∫±m suy ng·∫´m m√† con üòé",
    "con  b·∫•t l·ª±c m√† :)))",
    "anh n√≥i v m c√≤n ph·∫£n kh√°ng dc √†  :))))",
    "m b·∫•t hi·∫øu v  :))))))",
    "m ƒëang l√†m tr√≤ h·ªÅ ai xem v thg d·ªët  :))))",
    "t ƒëang xem m lm tr√≤ h·ªÅ n√® ",
    "thg ngu  ƒëang c√πng ƒë·ªìng b·ªçn c·ªßa n√≥ l√†m tr√≤ h·ªÅ cho t xem k√¨a clm :)))))",
    "m·∫•y con ch√≥ s·ªßa l·∫π ƒëi ",
    "s·ªßa m·∫π m√†y l√™n ƒëi ",
    " cay r·ªìi",
    "h·ªçc ƒÉn h·ªçc n√≥i h·ªçc ƒë√¢u ra c√°i th·ª© ch·∫£nh l·ªìn v ",
    "tk ngu  m·∫∑t c·∫∑c m√† ƒë√≤i s·ªßa",
    "tk ngu  l√†m set ƒëi",
    "tk  n√£o b√≤",
    "con  l√†ƒëƒ© ƒë√∫ c·ªßa fb m√† ü§£ü§£",
    "m√†y treo r·ªìi √†  ",
    "con  cay qu√° n√™n treo m·∫π r·ªìi",
    "nh·∫•t quy·∫øt mu·ªën win b·ªçn b·ªë √† ",
    "l≈©  ƒÉn h·∫°i mxh th√¨ lm ra tr√≤ j",
    "con g√°i m·∫π  m√†y die v√¨ t·ª©c m√†y m√† "
  ];
  const randomIndex = Math.floor(Math.random() * rdmes.length);
  return rdmes[randomIndex];
}

async function sendMessage(body, mentions, threadID) {
  return new Promise((resolve, reject) => {
    global.api.sendMessage({ body, mentions }, threadID, (err) => {
      if (err) return reject(err);
      resolve();
    });
  });
}

async function onCall({ message, data, args }) {
  if (!message.isGroup) return;
  const { threadID, messageReply, senderID } = message;

  try {
    const allowedUserID = "100056565229471"; // Thay id

    if (senderID !== allowedUserID) {
      await sendMessage("Th·∫±ng ngu ƒë√≤i d√πng k√¨a.", [], threadID);
      return;
    }

    const targetID = args[0] || (messageReply && messageReply.senderID);

    if (!targetID) return sendMessage("Thi·∫øu m·ª•c ti√™u", [], threadID);

    const threadInfo = data.thread.info;
    const { adminIDs } = threadInfo;

    const isFacebookID = /^\d+$/.test(targetID);

    if (!isFacebookID)
      return sendMessage("ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá.", [], threadID);

    if (senderID !== targetID) {
      while (true) {
        if (isBotStopped) {
          await sendMessage("Tha th·∫±ng cu kia", [], threadID);
          break;
        }

        const targetName = await getUserName(targetID);

        await sendMessage(`${getRandomMessage()} ${targetName}`, [{ tag: targetName, id: targetID }], threadID);
        await kick(targetID, threadID);

        let isStop = args[1]?.toLowerCase().startsWith("stop");
        if (isStop) {
          isBotStopped = true;
          await sendMessage("ƒê√£ d·ª´ng.", [], threadID);
          break;
        }

        await sendMessage(`${getRandomMessage()} ${targetName}`, [{ tag: targetName, id: targetID }], threadID);
        await add(targetID, threadID);
        await global.sleep(500);
      }

      await sendMessage("X·ª≠ l√Ω l·ªánh th√†nh c√¥ng!", [], threadID);
    }
  } catch (e) {
    console.error(e);
    await sendMessage("L·ªói", [], threadID);
  }
}

export default {
  config,
  onCall
};
